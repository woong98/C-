### 다형성
여러 형태를 받아들일 수 있는 성질, 상황에 따라 의미를 다르게 부여할 수 있는 특성
---
### 가상 함수
다형성의 구현에 있어서 핵심적인 역할을 한다
- 기본적으로 부모에 자식을 대입가능하지만, 자식에 부모를 대입할 수는 없다. 
- <strong>부모는 자식을 가리킬 수 있다</strong>
-> 이 경우에는 부모에 존재하는 멤버만을 가리킬 수 있다!!!
여기서 생긴 의문 : 그러면, 실제로 클래스가 메모리에 구현될 때에는, 부모의 멤버들 아래에 자식 멤버들이 들어가는 방향으로
구현이 되어야 할 것 같은데, 실제로 그러한가 
```c++=
class Base
{
public:
     void OutMessage() { printf("Base Class\n"); }
};

class Derived : public Base
{
public:
     void OutMessage() { printf("Derived Class\n"); }
};
 
void main()
{
     Base B,*pB;
     Derived D;
 
     pB=&B;
     pB->OutMessage();
     pB=&D;
     pB->OutMessage();
}
```
아래의 예시에서, 의도는 다른 메시지가 출력되는 결과일것이다. 하지만 이 경우에는 부모가 자식을 가리키는 경우, 부모의 멤버에 대해서 접근이 가능하다. 따라서 Base Class가 2회 출력되는 결과이다. 이 것을 위해서 가상함수를 사용할 수 있다.
<strong>virtual</strong>키워드를 void앞에 붙이는 형태를 통해서 가상함수로 작성할 수 있다.
- 가상함수의 경우에는 컴파일시가 아닌, 런타임에서 어떤 것을 가리키는지 결정된다. 
- 가상함수에서 동적 결합은 멤버 함수를 포인터(또는 레퍼런스)로 호출할 때만 동작
- 동적 결합을 위해서 가상 함수 테이블을 가지는데, 이는 컴파일러에서 어떤 식으로 구현할지 결정한다. 
- 기반 클래스의 파괴자는 반드시 가상으로 선언해야 한다 
=> 이 경우에 대해서는 파괴될 때는 반대 순서로 파괴자가 호출되기 때문에, 파괴자에 가상함수를 사용하지 않은 경우에 대해서는 제대로된 메모리 해제를 하지 못할 수 있다.
```c++= 
Derived D;
Base *pB;
pB=new Derived;
delete pB;
```
위의 예시에서 pB를 삭제하는 경우, 가상함수가 아니라면 Derived에 대한 파괴자를 호출할 수 없는 상황이 발생할 수 있기 때문에, 파괴자에 virtual 키워드를 붙여주는 방식이 필요하다.

결과적으로
1. 자식 클래스가 파생될 가능성이 있는 경우 
2. 자식 클래스에서 다른 동작을 요구할경우 
3. 포인터를 사용해서 호출 가능성이 존재하는 경우
가상함수를 사용할 수 있다. 